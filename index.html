<!DOCTYPE html>
<html>
<head>
  <title>MX Web Prototype</title>
  <style>
    body { margin: 0; overflow: hidden; }
    #ui { position: fixed; top: 20px; left: 20px; color: white; font-family: Arial; }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <div id="ui">Speed: <span id="speed">0</span> km/h</div>

  <!-- Babylon.js Core -->
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@babylonjs/core/Loading/loadingScreen.min.js"></script>
  
  <!-- Physics Engine -->
  <script src="https://preview.babylonjs.com/ammo.js"></script>

  <script>
    const createScene = async () => {
      // Engine setup
      const canvas = document.getElementById('renderCanvas');
      const engine = new BABYLON.Engine(canvas, true);
      
      // Scene creation
      const scene = new BABYLON.Scene(engine);
      scene.enablePhysics(new BABYLON.Vector3(0, -9.81, 0), new BABYLON.AmmoJSPlugin());

      // Camera
      const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI/2, Math.PI/3, 15, new BABYLON.Vector3(0, 2, 0), scene);
      camera.attachControl(camera, true);

      // Lighting
      const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);
      light.intensity = 0.7;

      // Terrain
      const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 100, height: 100 }, scene);
      ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0 }, scene);
      
      // Dirt bike
      const bike = await BABYLON.SceneLoader.ImportMeshAsync("", "https://assets.babylonjs.com/meshes/", "car.glb", scene);
      bike.meshes[0].position.y = 2;
      bike.meshes[0].physicsImpostor = new BABYLON.PhysicsImpostor(
        bike.meshes[0], 
        BABYLON.PhysicsImpostor.MeshImpostor, 
        { mass: 200, friction: 1.5 }, 
        scene
      );

      // Suspension simulation
      const suspensionSpring = {
        stiffness: 350,
        damping: 50,
        restLength: 0.5
      };

      // Controls
      const inputMap = {};
      scene.actionManager = new BABYLON.ActionManager(scene);
      scene.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyDownTrigger, (evt) => {
          inputMap[evt.sourceEvent.key] = true;
        })
      );
      scene.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(BABYLON.ActionManager.OnKeyUpTrigger, (evt) => {
          inputMap[evt.sourceEvent.key] = false;
        })
      );

      // Game loop
      scene.onBeforeRenderObservable.add(() => {
        // Throttle control
        if(inputMap['w']) {
          bike.meshes[0].physicsImpostor.applyForce(
            new BABYLON.Vector3(0, 0, 500),
            bike.meshes[0].getAbsolutePosition()
          );
        }

        // Suspension effect
        bike.meshes[0].physicsImpostor.applyForce(
          new BABYLON.Vector3(0, suspensionSpring.stiffness * 2, 0),
          bike.meshes[0].getAbsolutePosition()
        );

        // Update UI
        document.getElementById('speed').textContent = 
          Math.abs(bike.meshes[0].physicsImpostor.getLinearVelocity().z * 3.6).toFixed(1);
      });

      return scene;
    };

    // Initialize
    const canvas = document.getElementById('renderCanvas');
    const scene = createScene().then(scene => {
      engine.runRenderLoop(() => scene.render());
    });

    window.addEventListener('resize', () => engine.resize());
  </script>
</body>
</html>
